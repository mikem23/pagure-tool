#!/usr/bin/python

import click
import json
import pprint
import requests
import sys
import time
import urllib

BASEURL='https://pagure.io'


def pcall(path, query=None, api=0, baseurl=BASEURL):
    url = "%s/api/%s/%s" % (baseurl, api, path)
    if isinstance(query, basestring):
        url = "%s?%s" % (url, query)
    elif query != None:
        query = urllib.urlencode(query)
        url = "%s?%s" % (url, query)
    print "DEBUG: %s" % url
    r = requests.get(url)
    try:
        data = r.json()
    except Exception:
        print "Server returned bad value"
        print r
        raise
    if 'error_code' in data:
        print "%(error_code)s: %(error)s" % data
        sys.exit(1)
    return data


@click.group()
def pg():
    # main command
    pass


@pg.group()
def pr():
    pass


@pr.command('info')
@click.argument('project')
@click.argument('prid')
def prinfo(project, prid):
    pr = pcall("%s/pull-request/%s" % (project, prid))
    import pprint; pprint.pprint(pr)

    for comment in pr['comments']:
        cts = float(comment['date_created'])
        comment['_username'] = comment['user']['name']
        comment['_tstr'] = time.asctime(time.localtime(float(cts)))
        print "Comment by %(_username)s on %(_tstr)s:" % comment
        print
        print comment['comment']
        print

    print "PR#%(id)i: %(title)s" % pr
    print
    print "Merges #%(id)i" % pr
    print "https://pagure.io/koji/pull-request/%(id)i" % pr
    print
    print "STATUS: %(status)s" % pr
    if pr.get('repo_from'):
        # should we use fullname field?
        # or 
        print "Fork: %s/%s" % (BASEURL, pr['repo_from']['fullname'])
    elif pr.get('remote_git'):
        print "Remote: %(remote_git)s" % pr
    else:
        print "Can't determine repo?"
        sys.exit(1)
    print "%(branch_from)s -> %(branch)s" % pr
    if pr['status'] != 'Open':
        print '...'


@pr.command('checkout')
@click.argument('project')
@click.argument('prid')
def pr_checkout(project, prid):
    pr = pcall("%s/pull-request/%s" % (project, prid))
    url, branch = get_pr_source(pr)
    print "git fetch '%s' '%s'" % (url, branch)
    print "git checkout -b pr%s FETCH_HEAD" % prid
    # TODO: recycle branch if it exists
    # TODO: --follow option


def get_pr_source(prinfo):
    """Returns a pair [url, branch]"""
    branch = prinfo['branch_from']
    if prinfo.get('repo_from'):
        # apparently, for this we can use the fullname
        url = "https://pagure.io/%(fullname)s.git" % prinfo['repo_from']
    elif prinfo.get('remote_git'):
        url = prinfo['remote_git']
    else:
        raise RuntimeError("Can't determine pr source")
    return url, branch


@pr.command('list')
@click.argument('project')
@click.option('-o', '--order', default='updated_on')
def pr_list(project, order):
    data = pcall('%s/pull-requests' % project)
    count = data['total_requests']
    prs = data['requests']
    if order:
        o_keys = order.split(',')
        def sortkey(pr):
            return [pr.get(k) for k in o_keys]
        prs.sort(key=sortkey)
    for pr in prs:
        print "PR#%(id)i: %(title)s [%(status)s]" % pr


def project_path(project):
    parts = []
    if project.get('parent'):
        parts.append('fork')
        parts.append(project['user']['name'])
    if project.get('namespace'):
        parts.append(project.get('namespace'))
    parts.append(project['name'])
    return '/'.join(parts)


@pg.command(name='list-projects')
@click.argument('pattern')
@click.option('--fork/--no-fork', default=False)
def list_projects(pattern, **opts):
    if pattern:
        opts['pattern'] = pattern
    data = pcall('projects', opts)
    count = data['total_projects']
    for proj in data['projects']:
        proj['_path'] = project_path(proj)
        print "%(_path)s: %(description)s" % proj


@pg.group()
def project():
    pass

@project.command('git-urls')
@click.argument('name')
def git_urls(name):
    data = pcall("%s/git/urls" % name)
    for url in data['urls']:  # not a list for some reason
        print "%s: %s" % (url, data['urls'][url])


@project.command('git-tags')
@click.argument('name')
def git_tags(name):
    data = pcall("%s/git/tags" % name)
    for tag in data['tags']:
        print tag


@project.command('git-branches')
@click.argument('name')
def git_branches(name):
    data = pcall("%s/git/branches" % name)
    for br in data['branches']:
        print br


@project.command()
@click.argument('name')
def watchers(name):
    data = pcall("%s/watchers" % name)
    for row in data['watchers']:  # dict, not list
        wtype = data['watchers'][row]
        print "%s: %s" % (row, wtype)


@project.command("info")
@click.argument('name')
def projectinfo(name):
    data = pcall(name)
    pprint.pprint(data)


@pg.group()
def issue():
    pass


@issue.command(name='list')
@click.argument('project')
@click.option('-o', '--order', default='updated_on')
@click.option('--status', help="filter by status")
@click.option('--tags', help="filter by tags")
@click.option('--author', help="filter by author")
@click.option('--assignee', help="filter by assignee")
@click.option('--priority', help="filter by priority")
def issuelist(project, order, **opts):
    for k in list(opts):
        if opts[k] is None:
            del opts[k]
    data = pcall("%s/issues" % project, opts)
    issues = data['issues']
    if order:
        o_keys = order.split(',')
        def sortkey(row):
            return [row.get(k) for k in o_keys]
        issues.sort(key=sortkey)
    for row in data['issues']:
        print "%(id)s: %(title)s" % row


@issue.command("info")
@click.argument('name')
@click.argument('issueid')
def issueinfo(name, issueid):
    data = pcall("%s/issue/%s" % (name, issueid))
    pprint.pprint(data)





if __name__ == '__main__':
    pg()
